{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["List","require","colors","0","1","2","3","4","5","6","7","8","Square","touched","value","mine","onClick","bClass","textColor","text","textWeight","style","color","fontWeight","className","disabled","Board","props","state","grid","createBoard","size","InBounds","bind","pos","every","x","row","column","Array","fill","map","_","index","Math","PI","angle","round","sin","cos","filter","r","c","length","minedNeighbors","this","getSurroundingNeighbors","revealCellsRecursively","neighbors","push","cellValid","y","includes","reduce","accumNeighbors","mChance","newCell","random","mineNeighbors","getMinedNeighbors","cell","alert","revealCell","forEach","element","setState","rIndex","key","item","cIndex","handleClick","React","Component","App","id","href","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.48b43354.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\nconst {List} = require('immutable')\n\nlet colors = {\n  0: \"white\",\n  1: \"#b3ffb3\",\n  2: \"#4dff4d\",\n  3: \"#ffff00\",\n  4: \"#ffcc00\",\n  5: \"#ff9933\",\n  6: \"#ff6600\",\n  7: \"#ff3300\",\n  8: \"#ff0000\"\n\n}\n\nfunction Square({touched, mine, value, onClick}) {\n  let bClass = touched ? \"touched\" : \"untouched\"\n  let textColor =  colors[value];\n  let text = touched ? value : \"\";\n  let textWeight = value > 3 ? \"bold\" : \"normal\"\n  return( <button style ={{color: textColor, fontWeight: textWeight}} className={bClass} onClick={onClick} disabled={touched}>{text}</button>)\n}\n\nclass Board extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {grid: this.createBoard(props.size, 0.2)}\n    this.InBounds = this.InBounds.bind(this);\n  }\n\n  newCell(mine){\n    return {mine: mine, touched: false}\n  }\n\n  InBounds(pos, size){\n    return pos.every(x => 0 <= x && x < size);\n  }\n\n  //Returns the 8 positions as [row, column] surrounding the given position\n  getSurroundingNeighbors(row, column, size) {\n    \n    //Converts an angle into a coordinate pair for indexing\n    let angleToVec = (angle) => [row + Math.round(Math.sin(angle)), column + Math.round(Math.cos(angle))]\n\n    //Fill an array with 8 angles pointing at each cell around the given position. [0, Pi/4, 2*Pi/4 .. 7*Pi/4]\n    return Array(8)\n      .fill(null)\n      .map((_, index) => index * Math.PI / 4)\n      .map(angleToVec) //Convert each angle into its rounded vector to get the position of each neighbor [[row+1, column], [row+1, column+1], [row, column + 1], ... ]\n      .filter(pos => pos.every(x => 0 <= x && x < size)) //Remove out of bounds items\n  }\n\n  getMinedNeighbors(grid, r, c){\n    let size = grid.length;\n    return grid[r][c].minedNeighbors = this.getSurroundingNeighbors(r,c, size)\n      .filter(pos => {let [r,c] = pos; return grid[r][c].mine}) //Remove cells that aren't mines\n      .length //Return length as the number of mines surrounding a cell\n  }\n\n  revealCell(grid, r, c){\n    if (grid[r][c].minedNeighbors > 0){\n      return List([[r,c]])\n    }else{\n      return this.revealCellsRecursively(grid, r, c, List())\n    }\n  }\n\n  revealCellsRecursively(grid, r, c, neighbors){\n    if (grid[r][c].minedNeighbors > 0){\n      return neighbors.push(List([r,c]));\n    }else{\n      let cellValid = 0;\n      cellValid = ([y,x]) => !grid[y][x].mine && !grid[y][x].touched && !neighbors.includes(List([r,c]));\n      let validNeighbors = this.getSurroundingNeighbors(r, c, grid.length)\n        .filter(pos => cellValid(pos))\n      return validNeighbors.reduce((accumNeighbors, pos) => \n        this.revealCellsRecursively(grid, pos[0], pos[1], accumNeighbors), neighbors.push(List([r,c])))\n    }\n  }\n\n  createBoard(size, mChance) {\n    //Create 2d array indexed as grid[row][column]\n    let grid = Array(size).fill(null)\n      .map(_ =>\n        Array(size).fill(null)\n          .map(_ => this.newCell(Math.random() < mChance))\n      )\n\n    //Calculate the number of mines surrounding each cell\n    for (let r = 0; r < size; r++) {\n      for (let c = 0; c < size; c++) {\n        grid[r][c].mineNeighbors = this.getMinedNeighbors(grid, r, c);\n      }\n    }\n    return grid;\n  }\n\n  handleClick(r, c){\n    let grid  = this.state.grid;\n    let cell = grid[r][c];\n\n    if (cell.mine){\n      alert(\"Dead\");\n      return;\n    }\n\n    if (cell.touched){\n      return;\n    }\n\n    let cells = this.revealCell(grid,r,c)\n    cells.forEach(element => {\n      const [r,c] = element;\n      grid[r][c].touched = true;\n    });\n\n    this.setState({grid:grid})\n  }\n\n  render(){\n    let grid = this.state.grid;\n\n    return (grid.map((row, rIndex) => \n      <div key={rIndex}>\n        {row.map((item, cIndex) => \n          <Square onClick={()=> this.handleClick(rIndex, cIndex)} key={cIndex} mine={item.mine} touched={item.touched} value={item.minedNeighbors}></Square>\n        )}\n      </div>\n    ))\n  }\n}\n\nfunction App() {\n  return (\n    <div id=\"App\">\n      <h1>Mine Sweeper</h1>\n      <div id=\"Board\">\n      <Board size={10}></Board>\n      <a href=\"https://github.com/TCooper1996/MineSweeper/\" id=\"info\">github</a>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}