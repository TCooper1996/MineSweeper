{"version":3,"sources":["imgs/smile.svg","imgs/meh.svg","imgs/frown.svg","imgs/flag.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","List","require","livesImg","sad","meh","happy","colors","0","1","2","3","4","5","6","7","8","Square","touched","flagged","mine","value","onClick","onContextMenu","textColor","text","textWeight","className","src","flag","alt","classes","style","color","fontWeight","disabled","Board","props","safeSpaces","createBoard","size","reduce","row","filter","cell","length","state","flash","lives","grid","resetBoard","bind","this","map","setState","setTimeout","column","Array","fill","_","index","Math","PI","angle","round","sin","cos","pos","every","x","r","c","minedNeighbors","getSurroundingNeighbors","revealCellsRecursively","neighbors","push","cellValid","y","includes","accumNeighbors","mChance","newCell","random","getMinedNeighbors","cells","e","preventDefault","console","log","onGameEnd","prevState","revealCell","forEach","element","remainingCells","alert","newGrid","statusIcon","statusText","rIndex","key","item","cIndex","handleRightClick","handleClick","id","onAnimationEnd","React","Component","App","href","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f2996064.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/smile.985edeb5.svg\";","module.exports = __webpack_public_path__ + \"static/media/meh.b7a92f62.svg\";","module.exports = __webpack_public_path__ + \"static/media/frown.7ab58022.svg\";","module.exports = __webpack_public_path__ + \"static/media/flag.e82605c7.svg\";","import React from 'react';\nimport './App.css';\nimport happy from './imgs/smile.svg'\nimport meh from './imgs/meh.svg'\nimport sad from './imgs/frown.svg'\nimport flag from './imgs/flag.svg'\nconst { List } = require('immutable')\n\nlet livesImg = [\n    [sad, \"You have one life; be careful\"],\n    [meh, \"You have two lives\"],\n    [happy, \"You have three lives\"],\n]\n\nlet colors = {\n    0: \"white\",\n    1: \"#b3ffb3\",\n    2: \"#4dff4d\",\n    3: \"#ffff00\",\n    4: \"#ffcc00\",\n    5: \"#ff9933\",\n    6: \"#ff6600\",\n    7: \"#ff3300\",\n    8: \"#ff0000\"\n}\n\nfunction Square({ touched, flagged, mine, value, onClick, onContextMenu }) {\n    let textColor = colors[value];\n    let text = touched ? value : \"\";\n    let textWeight = value > 3 ? \"bold\" : \"normal\"\n\n    if (flagged){\n        return <img className=\"tile tileImg\" src={flag} alt=\"This tile has been flagged as a mine\" onContextMenu={onContextMenu}/>\n    }else{\n        let classes = \"\"\n        if (touched){\n            classes = mine ? \"mine\" : \"touched\"\n        }else{\n            classes = \"untouched\"\n        }\n        return <button className={`tile tileBtn ${classes}`} onContextMenu={onContextMenu} style={{ color: textColor, fontWeight: textWeight }} onClick={onClick} disabled={touched}>{text}</button>\n    }\n}\n\n\nclass Board extends React.Component {\n    constructor(props) {\n        super(props);\n        let grid = this.createBoard(props.size, 0.2);\n        let safeSpaces = grid.reduce((size, row) => size + row.filter(cell => !cell.mine).length)\n        this.state = {flash: false, lives: 2,  size: props.size, grid: this.createBoard(props.size, 0.2), safeSpaces: safeSpaces }\n        this.resetBoard = this.resetBoard.bind(this);\n    }\n\n    onGameEnd(){\n        let grid = this.state.grid;\n        grid\n        .map(row => row.map(cell => {cell.touched = true; return cell}));\n        this.setState({grid:grid})\n        setTimeout(this.resetBoard, 3000);\n\n    }\n\n    newCell(mine) {\n        return { mine: mine, touched: false, flagged: false }\n    }\n\n    //Returns the 8 positions as [row, column] surrounding the given position\n    getSurroundingNeighbors(row, column, size) {\n\n        //Converts an angle into a coordinate pair for indexing\n        let angleToVec = (angle) => [row + Math.round(Math.sin(angle)), column + Math.round(Math.cos(angle))]\n\n        //Fill an array with 8 angles pointing at each cell around the given position. [0, Pi/4, 2*Pi/4 .. 7*Pi/4]\n        return Array(8)\n            .fill(null)\n            .map((_, index) => index * Math.PI / 4)\n            .map(angleToVec) //Convert each angle into its rounded vector to get the position of each neighbor [[row+1, column], [row+1, column+1], [row, column + 1], ... ]\n            .filter(pos => pos.every(x => 0 <= x && x < size)) //Remove out of bounds items\n    }\n\n    //Returns the number of neighbors containing a mine\n    getMinedNeighbors(grid, r, c) {\n        let size = grid.length;\n        return grid[r][c].minedNeighbors = this.getSurroundingNeighbors(r, c, size)\n            .filter(pos => { let [r, c] = pos; return grid[r][c].mine }) //Remove cells that aren't mines\n            .length //Return length as the number of mines surrounding a cell\n    }\n\n    revealCell(grid, r, c) {\n        if (grid[r][c].minedNeighbors > 0) {\n            return List([[r, c]])\n        } else {\n            return this.revealCellsRecursively(grid, r, c, List())\n        }\n    }\n\n    revealCellsRecursively(grid, r, c, neighbors) {\n        if (grid[r][c].minedNeighbors > 0) {\n            return neighbors.push(List([r, c]));\n        } else {\n            let cellValid = 0;\n            cellValid = ([y, x]) => !grid[y][x].mine && !grid[y][x].touched && !neighbors.includes(List([r, c]));\n            let validNeighbors = this.getSurroundingNeighbors(r, c, grid.length)\n                .filter(pos => cellValid(pos))\n            return validNeighbors.reduce((accumNeighbors, pos) =>\n                this.revealCellsRecursively(grid, pos[0], pos[1], accumNeighbors), neighbors.push(List([r, c])))\n        }\n    }\n\n    createBoard(size, mChance) {\n        //Create 2d array indexed as grid[row][column]\n        let grid = Array(size).fill(null)\n            .map(_ =>\n                Array(size).fill(null)\n                    .map(_ => this.newCell(Math.random() < mChance))\n            )\n\n        //Calculate the number of mines surrounding each cell\n        for (let r = 0; r < size; r++) {\n            for (let c = 0; c < size; c++) {\n                grid[r][c].minedNeighbors = this.getMinedNeighbors(grid, r, c);\n            }\n        }\n        return grid;\n    }\n\n    remainingCells(grid) {\n        return grid.reduce((cells, row) => cells + row.filter(cell => !cell.mine && cell.touched).length)\n    }\n\n    handleRightClick(r, c, e){\n        e.preventDefault();\n        let grid = this.state.grid;\n        grid[r][c].flagged = !grid[r][c].flagged;\n        this.setState({grid:grid})\n        console.log(\"right click\");\n    }\n\n\n    handleClick(r, c) {\n        let grid = this.state.grid;\n        let cell = grid[r][c];\n\n        if (cell.mine) {\n            if (this.state.lives === 0){\n                this.onGameEnd();\n                return;\n            }else{\n                this.setState(function(prevState, _){\n                    return {lives: prevState.lives - 1}\n                })\n            }\n        }\n\n        if (cell.touched) {\n            return;\n        }\n\n        //Create a list of all cells that need to be revealed and update the grid.\n        let cells = this.revealCell(grid, r, c)\n        cells.forEach(element => {\n            const [r, c] = element;\n            grid[r][c].touched = true;\n        });\n\n        if (this.remainingCells(grid) === 0) {\n            alert(\"Congratulations!\");\n        }\n        this.setState({ grid: grid, flash: cell.mine})\n    }\n\n    resetBoard(){\n        let newGrid = this.createBoard(this.state.size, 0.2);\n        let safeSpaces = newGrid.reduce((size, row) => size + row.filter(x => !x.mine).length);\n        this.setState({ grid: newGrid, safeSpaces: safeSpaces, flash: false, lives:2});\n    }\n\n    render() {\n        let grid = this.state.grid;\n        let statusIcon = livesImg[this.state.lives][0];\n        let statusText = livesImg[this.state.lives][1];\n        let flash = this.state.flash;\n\n        return(\n            <div>{\n                grid.map((row, rIndex) =>{\n                return ( \n                    <div key={rIndex}>\n                        {row.map((item, cIndex) =>\n                            <Square flagged={grid[rIndex][cIndex].flagged} onContextMenu={(e) => this.handleRightClick(rIndex, cIndex, e)} onClick={() => this.handleClick(rIndex, cIndex)} key={cIndex} mine={item.mine} touched={item.touched} value={item.minedNeighbors}></Square>\n                        )}\n                    </div>)}\n                )}\n                <img id={flash ? 'statusFlashing': 'statusStatic'} onAnimationEnd={() => this.setState({flash:false})} src={statusIcon} alt={statusText}/>\n            </div>\n        )\n                \n    }\n}\n\nfunction App() {\n    return (\n        <div id=\"App\">\n            <h1>Mine Sweeper</h1>\n            <a href=\"https://github.com/TCooper1996/MineSweeper/\" id=\"info\">github</a>\n            <div id=\"Board\">\n                <Board size={10}></Board>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}