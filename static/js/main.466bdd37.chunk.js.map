{"version":3,"sources":["imgs/smile.svg","imgs/meh.svg","imgs/frown.svg","imgs/flag.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","List","require","livesImg","sad","meh","happy","colors","0","1","2","3","4","5","6","7","8","Square","touched","flagged","mine","value","onClick","onContextMenu","textColor","text","textWeight","className","src","flag","alt","classes","style","color","fontWeight","disabled","Board","props","mineChance","size","safeSpaces","createBoard","reduce","row","filter","cell","length","state","flash","lives","grid","resetBoard","bind","this","map","setState","setTimeout","column","Array","fill","_","index","Math","PI","angle","round","sin","cos","pos","every","x","r","c","minedNeighbors","getSurroundingNeighbors","revealCellsRecursively","neighbors","push","cellValid","y","includes","accumNeighbors","mChance","newCell","random","getMinedNeighbors","cells","e","preventDefault","onGameEnd","prevState","revealCell","forEach","element","remainingCells","alert","newGrid","statusIcon","statusText","rIndex","key","item","cIndex","handleRightClick","handleClick","id","onAnimationEnd","React","Component","App","href","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.466bdd37.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/smile.985edeb5.svg\";","module.exports = __webpack_public_path__ + \"static/media/meh.b7a92f62.svg\";","module.exports = __webpack_public_path__ + \"static/media/frown.7ab58022.svg\";","module.exports = __webpack_public_path__ + \"static/media/flag.e82605c7.svg\";","import React from 'react';\nimport './App.css';\nimport happy from './imgs/smile.svg'\nimport meh from './imgs/meh.svg'\nimport sad from './imgs/frown.svg'\nimport flag from './imgs/flag.svg'\nconst { List } = require('immutable')\n\nlet livesImg = [\n    [sad, \"You have one life; be careful\"],\n    [meh, \"You have two lives\"],\n    [happy, \"You have three lives\"],\n]\n\nlet colors = {\n    0: \"white\",\n    1: \"#b3ffb3\",\n    2: \"#4dff4d\",\n    3: \"#ffff00\",\n    4: \"#ffcc00\",\n    5: \"#ff9933\",\n    6: \"#ff6600\",\n    7: \"#ff3300\",\n    8: \"#ff0000\"\n}\n\n\nfunction Square({ touched, flagged, mine, value, onClick, onContextMenu }) {\n    let textColor = colors[value];\n    let text = touched ? value : \"\";\n    let textWeight = value > 3 ? \"bold\" : \"normal\"\n\n    if (flagged) {\n        return <img className=\"tile tileImg\" src={flag} alt=\"This tile has been flagged as a mine\" onContextMenu={onContextMenu} />\n    } else {\n        let classes = \"\"\n        if (touched) {\n            classes = mine ? \"mine\" : \"touched\"\n        } else {\n            classes = \"untouched\"\n        }\n        return <button className={`tile tileBtn ${classes}`} onContextMenu={onContextMenu} style={{ color: textColor, fontWeight: textWeight }} onClick={onClick} disabled={touched}>{text}</button>\n    }\n}\n\n\nclass Board extends React.Component {\n    constructor(props) {\n        super(props);\n        this.mineChance = props.mineChance;\n        this.size = props.size;\n        let grid = this.createBoard(props.size, props.mineChance);\n        let safeSpaces = grid.reduce((size, row) => size + row.filter(cell => !cell.mine).length)\n        this.state = { flash: false, lives: 2, grid: this.createBoard(props.size, props.mineChance), safeSpaces: safeSpaces }\n        this.resetBoard = this.resetBoard.bind(this);\n\n\n    }\n\n    onGameEnd() {\n        let grid = this.state.grid;\n        grid\n            .map(row => row.map(cell => { cell.touched = true; return cell }));\n        this.setState({ grid: grid })\n        setTimeout(this.resetBoard, 3000);\n\n    }\n\n    newCell(mine) {\n        return { mine: mine, touched: false, flagged: false }\n    }\n\n    //Returns the 8 positions as [row, column] surrounding the given position\n    getSurroundingNeighbors(row, column, size) {\n\n        //Converts an angle into a coordinate pair for indexing\n        let angleToVec = (angle) => [row + Math.round(Math.sin(angle)), column + Math.round(Math.cos(angle))]\n\n        //Fill an array with 8 angles pointing at each cell around the given position. [0, Pi/4, 2*Pi/4 .. 7*Pi/4]\n        return Array(8)\n            .fill(null)\n            .map((_, index) => index * Math.PI / 4)\n            .map(angleToVec) //Convert each angle into its rounded vector to get the position of each neighbor [[row+1, column], [row+1, column+1], [row, column + 1], ... ]\n            .filter(pos => pos.every(x => 0 <= x && x < size)) //Remove out of bounds items\n    }\n\n    //Returns the number of neighbors containing a mine\n    getMinedNeighbors(grid, r, c) {\n        let size = grid.length;\n        return grid[r][c].minedNeighbors = this.getSurroundingNeighbors(r, c, size)\n            .filter(pos => { let [r, c] = pos; return grid[r][c].mine }) //Remove cells that aren't mines\n            .length //Return length as the number of mines surrounding a cell\n    }\n\n    revealCell(grid, r, c) {\n        if (grid[r][c].minedNeighbors > 0) {\n            return List([[r, c]])\n        } else {\n            return this.revealCellsRecursively(grid, r, c, List())\n        }\n    }\n\n    revealCellsRecursively(grid, r, c, neighbors) {\n        if (grid[r][c].minedNeighbors > 0) {\n            return neighbors.push(List([r, c]));\n        } else {\n            let cellValid = 0;\n            cellValid = ([y, x]) => !grid[y][x].mine && !grid[y][x].touched && !neighbors.includes(List([r, c]));\n            let validNeighbors = this.getSurroundingNeighbors(r, c, grid.length)\n                .filter(pos => cellValid(pos))\n            return validNeighbors.reduce((accumNeighbors, pos) =>\n                this.revealCellsRecursively(grid, pos[0], pos[1], accumNeighbors), neighbors.push(List([r, c])))\n        }\n    }\n\n    createBoard(size, mChance) {\n        //Create 2d array indexed as grid[row][column]\n        let grid = Array(size).fill(null)\n            .map(_ =>\n                Array(size).fill(null)\n                    .map(_ => this.newCell(Math.random() < mChance))\n            )\n\n        //Calculate the number of mines surrounding each cell\n        for (let r = 0; r < size; r++) {\n            for (let c = 0; c < size; c++) {\n                grid[r][c].minedNeighbors = this.getMinedNeighbors(grid, r, c);\n            }\n        }\n        return grid;\n    }\n\n    remainingCells(grid) {\n        return grid.reduce((cells, row) => cells + row.filter(cell => !cell.mine && !cell.touched).length, 0)\n    }\n\n    handleRightClick(r, c, e) {\n        e.preventDefault();\n        let grid = this.state.grid;\n        grid[r][c].flagged = !grid[r][c].flagged;\n        this.setState({ grid: grid })\n    }\n\n\n    handleClick(r, c) {\n        let grid = this.state.grid;\n        let cell = grid[r][c];\n\n        if (cell.mine) {\n            if (this.state.lives === 0) {\n                this.onGameEnd();\n                return;\n            } else {\n                this.setState(function (prevState, _) {\n                    return { lives: prevState.lives - 1 }\n                })\n            }\n        }\n\n        if (cell.touched) {\n            return;\n        }\n\n        //Create a list of all cells that need to be revealed and update the grid.\n        let cells = this.revealCell(grid, r, c)\n        cells.forEach(element => {\n            const [r, c] = element;\n            grid[r][c].touched = true;\n        });\n        if (this.remainingCells(grid) === 0) {\n            alert(\"Congratulations!\");\n            this.resetBoard();\n            return;\n        }\n        this.setState({ grid: grid, flash: cell.mine })\n    }\n\n    resetBoard() {\n        let newGrid = this.createBoard(this.size, this.mineChance);\n        let safeSpaces = newGrid.reduce((size, row) => size + row.filter(x => !x.mine).length);\n        this.setState({ grid: newGrid, safeSpaces: safeSpaces, flash: false, lives: 2 });\n    }\n\n    render() {\n        let grid = this.state.grid;\n        let statusIcon = livesImg[this.state.lives][0];\n        let statusText = livesImg[this.state.lives][1];\n        let flash = this.state.flash;\n\n        return (\n            <div>{\n                grid.map((row, rIndex) => {\n                    return (\n                        <div key={rIndex}>\n                            {row.map((item, cIndex) =>\n                                <Square flagged={grid[rIndex][cIndex].flagged} onContextMenu={(e) => this.handleRightClick(rIndex, cIndex, e)} onClick={() => this.handleClick(rIndex, cIndex)} key={cIndex} mine={item.mine} touched={item.touched} value={item.minedNeighbors}></Square>\n                            )}\n                        </div>)\n                }\n                )}\n                <img id={flash ? 'statusFlashing' : 'statusStatic'} onAnimationEnd={() => this.setState({ flash: false })} src={statusIcon} alt={statusText} />\n            </div>\n        )\n\n    }\n}\n\nfunction App() {\n    return (\n        <div id=\"App\">\n            <h1>Mine Sweeper</h1>\n            <div id=\"Board\">\n                <Board mineChance={0.3} size={10}></Board>\n            </div>\n            <a href=\"https://github.com/TCooper1996/MineSweeper/\">github</a>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}